'use strict';

angular.module('d3', [])
  .factory('d3Service', ['$document', '$q', '$rootScope',
    function($document, $q, $rootScope) {
      var d = $q.defer();
      function onScriptLoad() {
        // Load client in the browser
        $rootScope.$apply(function() { d.resolve(window.d3); });
      };

      var scriptTag = $document[0].createElement('script');
      scriptTag.type = 'text/javascript';
      scriptTag.async = true;
      scriptTag.src = 'http://d3js.org/d3.v4.min.js';
      scriptTag.onreadystatechange = function () {
        if (this.readyState == 'complete') onScriptLoad();
      };
      scriptTag.onload = onScriptLoad;

      var s = $document[0].getElementsByTagName('body')[0];
      s.appendChild(scriptTag);
      return {
        d3: function() { return d.promise; }
      };
}]);


var module = angular.module('app', ['d3']);
module.config(function($locationProvider) {
  $locationProvider.html5Mode(true);
});
module.service('StockService', StockService);
module.controller('myController', myController);

function myController(StockService) {
  var model = this;
  var companyNames = [];
  var company = {};
  model.companiesNames = ['CSCO', 'MSFT', 'ADBE'];

  model.showCompany = function(name){
    if(!!company[name]){
      model.company = company[name];
      return;
    }
    company[name] = [];
    StockService.getCompanyDate(name).then(function(response){
      var data=response.quote;
      angular.forEach(data, function(value) {
        value.Date = new Date(value.Date.split('-').join(','));
        company[name].push(value);
        model.companyNames = companyNames;
        model.company = company[name];

      });
    }, function(error){
      alert(error.message);
    });
  };
};


function StockService($http, $q) {
  var domain = "http://query.yahooapis.com/v1/public/yql?q=";
  var query = "&format=json&diagnostics=true&env=http://datatables.org/alltables.env";

  return {
    getCompanyDate: function(name){
      var url = domain +
      encodeURI("select * from yahoo.finance.historicaldata where symbol in('"
       + name +
       "')and startDate = '2016-01-01' and endDate = '2016-06-30'") +
      query;

      var deferred = $q.defer();
      $http.get(url).then(function(response) {
        var date = angular.fromJson(response.data.query.results);
        deferred.resolve(date);
      }, function(error) {
        deferred.reject({ message: 'Problem with connection' });
      });
      return deferred.promise;
    }
  };
}

'use strict';

angular.module('app').directive('chart', ['d3Service', function(d3Service) {
  return {
    restrict: 'E',
    scope: {
      item: '=ngModel'
    },
    link: function(scope, element, iAttrs) {

      var item;

      function getDate(date) {
        return new Date(date);
      }
      d3Service.d3().then(function(d3) {


        scope.$watch('item', function(nVal) {
          if (!!nVal) {
            var svg;
            d3.select("#ID").remove();



            var data = angular.copy(nVal).reverse();

            var margin = { top: 20, right: 20, bottom: 410, left: 50 },
              margin2 = { top: 430, right: 20, bottom: 330, left: 50 },
              margin3 = { top: 500, right: 20, bottom: 40, left: 50 },
              width = 1200 - margin.left - margin.right,
              height = 800 - margin.top - margin.bottom,
              height2 = 800 - margin2.top - margin2.bottom,
              height3 = 800 - margin3.top - margin3.bottom;


            var x = d3.scaleTime().range([0, width]),
              x2 = d3.scaleTime().range([0, width]),
              x3 = d3.scaleBand().rangeRound([0, width]).padding(0.1).align(0.1),
              y = d3.scaleLinear().range([height, 0]),
              y2 = d3.scaleLinear().range([height2, 0]),
              y3 = d3.scaleLinear().range([height3, 0]);

            var xAxis = d3.axisBottom(x),
              xAxis2 = d3.axisBottom(x2),
              xAxis3 = d3.axisBottom(x3).tickFormat(d3.timeFormat("%m-%d")),
              yAxis = d3.axisLeft(y),
              yAxis3 = d3.axisLeft(y3);

            var brush = d3.brushX()
              .extent([
                [0, 0],
                [width, height2]
              ])
              .on("brush", brushed);

            svg = d3.select(element[0]).append("svg")
              .attr("id", "ID")
              .attr("width", width + margin.left + margin.right)
              .attr("height", height + margin.top + margin.bottom);

            svg.append("defs").append("clipPath")
              .attr("id", "clip")
              .append("rect")
              .attr("width", width)
              .attr("height", height);

            var focus = svg.append("g")
              .attr("class", "focus")
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            var context = svg.append("g")
              .attr("class", "context")
              .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

            var freg = svg.append("g")
              .attr("class", "freg")
              .attr("transform", "translate(" + margin3.left + "," + margin3.top + ")");




            x.domain(d3.extent(data, function(d) {
              return d.Date;
            }));
            y.domain([d3.min(data, function(d) {
              return d.Low;
            }), d3.max(data, function(d) {
              return d.High;
            })]);
            x2.domain(x.domain());
            y2.domain(y.domain());
            //x3.domain(x.domain());
            x3.domain(data.map(function(d) {
              return d.Date;
            }));

            y3.domain(y.domain());


            var area = d3.area()
              .curve(d3.curveMonotoneX)
              .x(function(d) {
                return x(d.Date);
              })
              .y0(height)
              .y1(function(d) {
                return y(d.Close);
              });

            focus.append("path")
              .data([data])
              .attr("class", "area")
              .attr("d", area);


            // append scatter plot to main chart area
            var dots = focus.append("g");
            dots.attr("clip-path", "url(#clip)");
            dots.selectAll("dot")
              .data(data)
              .enter().append("circle")
              .attr('class', 'dot')
              .attr("r", 3)
              .style("opacity", .5)
              .attr("cx", function(d) {
                return x(d.Date);
              })
              .attr("cy", function(d) {
                return y(d.Close);
              })
              .on('mouseover', function(d) {
                d3.select(this).attr('r', 7);

                var formatTime = d3.timeFormat("%e %B")


                div.html(
                    '<table>' + '<tr>' +
                    '<td>' + 'Date' + '</td>' +
                    '<td>' + formatTime(d.Date) + '</td>' + '</tr>' + '<tr>' +
                    '<td>' + 'Open' + '</td>' +
                    '<td>' + d.Open + '</td>' + '</tr>' + '<tr>' +
                    '<td>' + 'Close' + '</td>' +
                    '<td>' + d.Close + '</td>' + '</tr>' + '<tr>' +
                    '<td>' + 'High' + '</td>' +
                    '<td>' + d.High + '</td>' + '</tr>' + '<tr>' +
                    '<td>' + 'Low' + '</td>' +
                    '<td>' + d.Low + '</td>' + '</tr>' + '<tr>' +
                    '<td>' + 'Volume' + '</td>' +
                    '<td>' + d.Volume + '</td>' + '</tr>' + '</table>'
                  )
                  .style("left", (d3.event.pageX) + "px")
                  .style("top", (d3.event.pageY - parseInt(div.style('height'), 10)) + "px")
                  .transition()
                  .duration(200)
                  .style("opacity", .9)
              })
              .on('mouseout', function(d) {
                d3.select(this).attr('r', 3);
                div.transition()
                  .duration(500)
                  .style("opacity", 0);
              });

            focus.append("g")
              .attr("class", "axis axis--x")
              .attr("fill", "none")
              .attr("transform", "translate(0," + height + ")")
              .call(xAxis);

            focus.append("g")
              .attr("class", "axis axis--y")
              .call(yAxis);

            focus.append("text")
              .attr("transform", "rotate(-90)")
              .attr("y", 0 - margin.left)
              .attr("x", 0 - (height / 2))
              .attr("dy", "1em")
              .style("text-anchor", "middle")
              .text("Price");

            svg.append("text")
              .attr("transform",
                "translate(" + ((width + margin.right + margin.left) / 2) + " ," +
                margin3.top + ")")
              .style("text-anchor", "middle")
              .text("Date");

            // Define the div for the tooltip
            var div = d3.select(element[0]).append("div")
              .attr("class", "tooltip")
              .style("opacity", 0);



            // append scatter plot to brush chart area
            context.append("g")
              .attr("class", "axis axis--x")
              .attr("transform", "translate(0," + height2 + ")")
              .call(xAxis2);

            context.append("g")
              .attr("class", "brush")
              .call(brush)
              .call(brush.move, x.range());

            var area2 = d3.area()
              .curve(d3.curveMonotoneX)
              .x(function(d) {
                return x2(d.Date);
              })
              .y0(height2)
              .y1(function(d) {
                return y2(d.Close);
              });

            context.append("path")
              .datum(data)
              .attr("class", "area")
              .attr("d", area2);


            freg.append("g")
              .attr("class", "axis axis--x")
              .attr("transform", "translate(0," + height3 + ")")
              .call(xAxis3)
              .selectAll("text")
              .style("text-anchor", "end")
              .attr("dx", "-.8em")
              .attr("dy", "-.55em")
              .attr("transform", "rotate(-90)");

            freg.append("g")
              .attr("class", "axis axis--y")
              .call(yAxis3);

            // Add a rect for each date.
            var rect = freg.selectAll("rect")
              .data(data)
              .enter().append("rect")
              .attr("class", "bar")
              .attr("x", function(d) {
                return x3(d.Date);
              })
              .attr("y", function(d) {
                return y3(d.High);
              })
              .attr("height", function(d) {
                y3(d.High);
                y3(d.Low);

                return y3(d.Low) - y3(d.High);
              })
              .attr("width", x3.bandwidth());



            //create brush function redraw scatterplot with selection
            function brushed() {

              if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom


              var selection = d3.event.selection;
              x.domain(selection.map(x2.invert, x2));
              focus.select(".area").attr("d", area);
              focus.selectAll(".dot")
                .attr("cx", function(d) {
                  return x(d.Date);
                })
                .attr("cy", function(d) {
                  return y(d.Close);
                });
              focus.select(".axis--x").call(xAxis);

              x3.domain();


              var range = selection.map(x2.invert, x2);

              x3.domain(data.map(function(d) {
                if (range[0] <= d.Date && d.Date <= range[1])
                  return d.Date;
              }));


              freg.selectAll("rect")
                .attr("x", function(d) {

                  if (range[0] <= d.Date && d.Date <= range[1])
                    return x3(d.Date);
                })
                .attr("y", function(d) {
                  if (range[0] <= d.Date && d.Date <= range[1])
                    return y3(d.High);
                })
                .attr('date', function(d) {
                  if (range[0] <= d.Date && d.Date <= range[1])
                  return d.Date;
                })
                .attr("height", function(d) {

                  y3(d.High);
                  y3(d.Low);

                  if (range[0] <= d.Date && d.Date <= range[1])
                  return y3(d.Low) - y3(d.High);
                })
                .attr("width", x3.bandwidth());

              freg.select(".axis--x").call(xAxis3)
                .selectAll("text")
                .text(function(d) {

                  if(!!d){
                   var formatTime = d3.timeFormat("%m-%d");
                   return formatTime(d);
                  }})
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", "-.55em")
                .attr("transform", "rotate(-90)");

            }
          }
        });

      });
    }
  };
}]);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC5qcyIsImRpcmVjdGl2ZXMvY2hhcnQvY2hhcnQuZGlyZWN0aXZlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJtYWluLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ2QzJywgW10pXG4gIC5mYWN0b3J5KCdkM1NlcnZpY2UnLCBbJyRkb2N1bWVudCcsICckcScsICckcm9vdFNjb3BlJyxcbiAgICBmdW5jdGlvbigkZG9jdW1lbnQsICRxLCAkcm9vdFNjb3BlKSB7XG4gICAgICB2YXIgZCA9ICRxLmRlZmVyKCk7XG4gICAgICBmdW5jdGlvbiBvblNjcmlwdExvYWQoKSB7XG4gICAgICAgIC8vIExvYWQgY2xpZW50IGluIHRoZSBicm93c2VyXG4gICAgICAgICRyb290U2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkgeyBkLnJlc29sdmUod2luZG93LmQzKTsgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgc2NyaXB0VGFnID0gJGRvY3VtZW50WzBdLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0VGFnLnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgIHNjcmlwdFRhZy5hc3luYyA9IHRydWU7XG4gICAgICBzY3JpcHRUYWcuc3JjID0gJ2h0dHA6Ly9kM2pzLm9yZy9kMy52NC5taW4uanMnO1xuICAgICAgc2NyaXB0VGFnLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnKSBvblNjcmlwdExvYWQoKTtcbiAgICAgIH07XG4gICAgICBzY3JpcHRUYWcub25sb2FkID0gb25TY3JpcHRMb2FkO1xuXG4gICAgICB2YXIgcyA9ICRkb2N1bWVudFswXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdO1xuICAgICAgcy5hcHBlbmRDaGlsZChzY3JpcHRUYWcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZDM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZC5wcm9taXNlOyB9XG4gICAgICB9O1xufV0pO1xuXG5cbnZhciBtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWydkMyddKTtcbm1vZHVsZS5jb25maWcoZnVuY3Rpb24oJGxvY2F0aW9uUHJvdmlkZXIpIHtcbiAgJGxvY2F0aW9uUHJvdmlkZXIuaHRtbDVNb2RlKHRydWUpO1xufSk7XG5tb2R1bGUuc2VydmljZSgnU3RvY2tTZXJ2aWNlJywgU3RvY2tTZXJ2aWNlKTtcbm1vZHVsZS5jb250cm9sbGVyKCdteUNvbnRyb2xsZXInLCBteUNvbnRyb2xsZXIpO1xuXG5mdW5jdGlvbiBteUNvbnRyb2xsZXIoU3RvY2tTZXJ2aWNlKSB7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIHZhciBjb21wYW55TmFtZXMgPSBbXTtcbiAgdmFyIGNvbXBhbnkgPSB7fTtcbiAgbW9kZWwuY29tcGFuaWVzTmFtZXMgPSBbJ0NTQ08nLCAnTVNGVCcsICdBREJFJ107XG5cbiAgbW9kZWwuc2hvd0NvbXBhbnkgPSBmdW5jdGlvbihuYW1lKXtcbiAgICBpZighIWNvbXBhbnlbbmFtZV0pe1xuICAgICAgbW9kZWwuY29tcGFueSA9IGNvbXBhbnlbbmFtZV07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbXBhbnlbbmFtZV0gPSBbXTtcbiAgICBTdG9ja1NlcnZpY2UuZ2V0Q29tcGFueURhdGUobmFtZSkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG4gICAgICB2YXIgZGF0YT1yZXNwb25zZS5xdW90ZTtcbiAgICAgIGFuZ3VsYXIuZm9yRWFjaChkYXRhLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YWx1ZS5EYXRlID0gbmV3IERhdGUodmFsdWUuRGF0ZS5zcGxpdCgnLScpLmpvaW4oJywnKSk7XG4gICAgICAgIGNvbXBhbnlbbmFtZV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIG1vZGVsLmNvbXBhbnlOYW1lcyA9IGNvbXBhbnlOYW1lcztcbiAgICAgICAgbW9kZWwuY29tcGFueSA9IGNvbXBhbnlbbmFtZV07XG5cbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uKGVycm9yKXtcbiAgICAgIGFsZXJ0KGVycm9yLm1lc3NhZ2UpO1xuICAgIH0pO1xuICB9O1xufTtcblxuXG5mdW5jdGlvbiBTdG9ja1NlcnZpY2UoJGh0dHAsICRxKSB7XG4gIHZhciBkb21haW4gPSBcImh0dHA6Ly9xdWVyeS55YWhvb2FwaXMuY29tL3YxL3B1YmxpYy95cWw/cT1cIjtcbiAgdmFyIHF1ZXJ5ID0gXCImZm9ybWF0PWpzb24mZGlhZ25vc3RpY3M9dHJ1ZSZlbnY9aHR0cDovL2RhdGF0YWJsZXMub3JnL2FsbHRhYmxlcy5lbnZcIjtcblxuICByZXR1cm4ge1xuICAgIGdldENvbXBhbnlEYXRlOiBmdW5jdGlvbihuYW1lKXtcbiAgICAgIHZhciB1cmwgPSBkb21haW4gK1xuICAgICAgZW5jb2RlVVJJKFwic2VsZWN0ICogZnJvbSB5YWhvby5maW5hbmNlLmhpc3RvcmljYWxkYXRhIHdoZXJlIHN5bWJvbCBpbignXCJcbiAgICAgICArIG5hbWUgK1xuICAgICAgIFwiJylhbmQgc3RhcnREYXRlID0gJzIwMTYtMDEtMDEnIGFuZCBlbmREYXRlID0gJzIwMTYtMDYtMzAnXCIpICtcbiAgICAgIHF1ZXJ5O1xuXG4gICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgJGh0dHAuZ2V0KHVybCkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB2YXIgZGF0ZSA9IGFuZ3VsYXIuZnJvbUpzb24ocmVzcG9uc2UuZGF0YS5xdWVyeS5yZXN1bHRzKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShkYXRlKTtcbiAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdCh7IG1lc3NhZ2U6ICdQcm9ibGVtIHdpdGggY29ubmVjdGlvbicgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ2FwcCcpLmRpcmVjdGl2ZSgnY2hhcnQnLCBbJ2QzU2VydmljZScsIGZ1bmN0aW9uKGQzU2VydmljZSkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRScsXG4gICAgc2NvcGU6IHtcbiAgICAgIGl0ZW06ICc9bmdNb2RlbCdcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBpQXR0cnMpIHtcblxuICAgICAgdmFyIGl0ZW07XG5cbiAgICAgIGZ1bmN0aW9uIGdldERhdGUoZGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG4gICAgICB9XG4gICAgICBkM1NlcnZpY2UuZDMoKS50aGVuKGZ1bmN0aW9uKGQzKSB7XG5cblxuICAgICAgICBzY29wZS4kd2F0Y2goJ2l0ZW0nLCBmdW5jdGlvbihuVmFsKSB7XG4gICAgICAgICAgaWYgKCEhblZhbCkge1xuICAgICAgICAgICAgdmFyIHN2ZztcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNJRFwiKS5yZW1vdmUoKTtcblxuXG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gYW5ndWxhci5jb3B5KG5WYWwpLnJldmVyc2UoKTtcblxuICAgICAgICAgICAgdmFyIG1hcmdpbiA9IHsgdG9wOiAyMCwgcmlnaHQ6IDIwLCBib3R0b206IDQxMCwgbGVmdDogNTAgfSxcbiAgICAgICAgICAgICAgbWFyZ2luMiA9IHsgdG9wOiA0MzAsIHJpZ2h0OiAyMCwgYm90dG9tOiAzMzAsIGxlZnQ6IDUwIH0sXG4gICAgICAgICAgICAgIG1hcmdpbjMgPSB7IHRvcDogNTAwLCByaWdodDogMjAsIGJvdHRvbTogNDAsIGxlZnQ6IDUwIH0sXG4gICAgICAgICAgICAgIHdpZHRoID0gMTIwMCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICBoZWlnaHQgPSA4MDAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSxcbiAgICAgICAgICAgICAgaGVpZ2h0MiA9IDgwMCAtIG1hcmdpbjIudG9wIC0gbWFyZ2luMi5ib3R0b20sXG4gICAgICAgICAgICAgIGhlaWdodDMgPSA4MDAgLSBtYXJnaW4zLnRvcCAtIG1hcmdpbjMuYm90dG9tO1xuXG5cbiAgICAgICAgICAgIHZhciB4ID0gZDMuc2NhbGVUaW1lKCkucmFuZ2UoWzAsIHdpZHRoXSksXG4gICAgICAgICAgICAgIHgyID0gZDMuc2NhbGVUaW1lKCkucmFuZ2UoWzAsIHdpZHRoXSksXG4gICAgICAgICAgICAgIHgzID0gZDMuc2NhbGVCYW5kKCkucmFuZ2VSb3VuZChbMCwgd2lkdGhdKS5wYWRkaW5nKDAuMSkuYWxpZ24oMC4xKSxcbiAgICAgICAgICAgICAgeSA9IGQzLnNjYWxlTGluZWFyKCkucmFuZ2UoW2hlaWdodCwgMF0pLFxuICAgICAgICAgICAgICB5MiA9IGQzLnNjYWxlTGluZWFyKCkucmFuZ2UoW2hlaWdodDIsIDBdKSxcbiAgICAgICAgICAgICAgeTMgPSBkMy5zY2FsZUxpbmVhcigpLnJhbmdlKFtoZWlnaHQzLCAwXSk7XG5cbiAgICAgICAgICAgIHZhciB4QXhpcyA9IGQzLmF4aXNCb3R0b20oeCksXG4gICAgICAgICAgICAgIHhBeGlzMiA9IGQzLmF4aXNCb3R0b20oeDIpLFxuICAgICAgICAgICAgICB4QXhpczMgPSBkMy5heGlzQm90dG9tKHgzKS50aWNrRm9ybWF0KGQzLnRpbWVGb3JtYXQoXCIlbS0lZFwiKSksXG4gICAgICAgICAgICAgIHlBeGlzID0gZDMuYXhpc0xlZnQoeSksXG4gICAgICAgICAgICAgIHlBeGlzMyA9IGQzLmF4aXNMZWZ0KHkzKTtcblxuICAgICAgICAgICAgdmFyIGJydXNoID0gZDMuYnJ1c2hYKClcbiAgICAgICAgICAgICAgLmV4dGVudChbXG4gICAgICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgICAgICAgIFt3aWR0aCwgaGVpZ2h0Ml1cbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgLm9uKFwiYnJ1c2hcIiwgYnJ1c2hlZCk7XG5cbiAgICAgICAgICAgIHN2ZyA9IGQzLnNlbGVjdChlbGVtZW50WzBdKS5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcIklEXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodClcbiAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pO1xuXG4gICAgICAgICAgICBzdmcuYXBwZW5kKFwiZGVmc1wiKS5hcHBlbmQoXCJjbGlwUGF0aFwiKVxuICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIFwiY2xpcFwiKVxuICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoKVxuICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICB2YXIgZm9jdXMgPSBzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZm9jdXNcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY29udGV4dFwiKVxuICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbjIubGVmdCArIFwiLFwiICsgbWFyZ2luMi50b3AgKyBcIilcIik7XG5cbiAgICAgICAgICAgIHZhciBmcmVnID0gc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImZyZWdcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4zLmxlZnQgKyBcIixcIiArIG1hcmdpbjMudG9wICsgXCIpXCIpO1xuXG5cblxuXG4gICAgICAgICAgICB4LmRvbWFpbihkMy5leHRlbnQoZGF0YSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZC5EYXRlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgeS5kb21haW4oW2QzLm1pbihkYXRhLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkLkxvdztcbiAgICAgICAgICAgIH0pLCBkMy5tYXgoZGF0YSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZC5IaWdoO1xuICAgICAgICAgICAgfSldKTtcbiAgICAgICAgICAgIHgyLmRvbWFpbih4LmRvbWFpbigpKTtcbiAgICAgICAgICAgIHkyLmRvbWFpbih5LmRvbWFpbigpKTtcbiAgICAgICAgICAgIC8veDMuZG9tYWluKHguZG9tYWluKCkpO1xuICAgICAgICAgICAgeDMuZG9tYWluKGRhdGEubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGQuRGF0ZTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgeTMuZG9tYWluKHkuZG9tYWluKCkpO1xuXG5cbiAgICAgICAgICAgIHZhciBhcmVhID0gZDMuYXJlYSgpXG4gICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcbiAgICAgICAgICAgICAgLngoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4KGQuRGF0ZSk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC55MChoZWlnaHQpXG4gICAgICAgICAgICAgIC55MShmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHkoZC5DbG9zZSk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb2N1cy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgIC5kYXRhKFtkYXRhXSlcbiAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImFyZWFcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyZWEpO1xuXG5cbiAgICAgICAgICAgIC8vIGFwcGVuZCBzY2F0dGVyIHBsb3QgdG8gbWFpbiBjaGFydCBhcmVhXG4gICAgICAgICAgICB2YXIgZG90cyA9IGZvY3VzLmFwcGVuZChcImdcIik7XG4gICAgICAgICAgICBkb3RzLmF0dHIoXCJjbGlwLXBhdGhcIiwgXCJ1cmwoI2NsaXApXCIpO1xuICAgICAgICAgICAgZG90cy5zZWxlY3RBbGwoXCJkb3RcIilcbiAgICAgICAgICAgICAgLmRhdGEoZGF0YSlcbiAgICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwiY2lyY2xlXCIpXG4gICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdkb3QnKVxuICAgICAgICAgICAgICAuYXR0cihcInJcIiwgMylcbiAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAuNSlcbiAgICAgICAgICAgICAgLmF0dHIoXCJjeFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgoZC5EYXRlKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHkoZC5DbG9zZSk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdyJywgNyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0VGltZSA9IGQzLnRpbWVGb3JtYXQoXCIlZSAlQlwiKVxuXG5cbiAgICAgICAgICAgICAgICBkaXYuaHRtbChcbiAgICAgICAgICAgICAgICAgICAgJzx0YWJsZT4nICsgJzx0cj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzx0ZD4nICsgJ0RhdGUnICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAgICAgICAgICc8dGQ+JyArIGZvcm1hdFRpbWUoZC5EYXRlKSArICc8L3RkPicgKyAnPC90cj4nICsgJzx0cj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzx0ZD4nICsgJ09wZW4nICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAgICAgICAgICc8dGQ+JyArIGQuT3BlbiArICc8L3RkPicgKyAnPC90cj4nICsgJzx0cj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzx0ZD4nICsgJ0Nsb3NlJyArICc8L3RkPicgK1xuICAgICAgICAgICAgICAgICAgICAnPHRkPicgKyBkLkNsb3NlICsgJzwvdGQ+JyArICc8L3RyPicgKyAnPHRyPicgK1xuICAgICAgICAgICAgICAgICAgICAnPHRkPicgKyAnSGlnaCcgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICAgICAgICAgJzx0ZD4nICsgZC5IaWdoICsgJzwvdGQ+JyArICc8L3RyPicgKyAnPHRyPicgK1xuICAgICAgICAgICAgICAgICAgICAnPHRkPicgKyAnTG93JyArICc8L3RkPicgK1xuICAgICAgICAgICAgICAgICAgICAnPHRkPicgKyBkLkxvdyArICc8L3RkPicgKyAnPC90cj4nICsgJzx0cj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzx0ZD4nICsgJ1ZvbHVtZScgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICAgICAgICAgJzx0ZD4nICsgZC5Wb2x1bWUgKyAnPC90ZD4nICsgJzwvdHI+JyArICc8L3RhYmxlPidcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIC5zdHlsZShcImxlZnRcIiwgKGQzLmV2ZW50LnBhZ2VYKSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgIC5zdHlsZShcInRvcFwiLCAoZDMuZXZlbnQucGFnZVkgLSBwYXJzZUludChkaXYuc3R5bGUoJ2hlaWdodCcpLCAxMCkpICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDIwMClcbiAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgLjkpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ3InLCAzKTtcbiAgICAgICAgICAgICAgICBkaXYudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZvY3VzLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImF4aXMgYXhpcy0teFwiKVxuICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuXG4gICAgICAgICAgICBmb2N1cy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJheGlzIGF4aXMtLXlcIilcbiAgICAgICAgICAgICAgLmNhbGwoeUF4aXMpO1xuXG4gICAgICAgICAgICBmb2N1cy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKC05MClcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDAgLSBtYXJnaW4ubGVmdClcbiAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDAgLSAoaGVpZ2h0IC8gMikpXG4gICAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIxZW1cIilcbiAgICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgICAgLnRleHQoXCJQcmljZVwiKTtcblxuICAgICAgICAgICAgc3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICBcInRyYW5zbGF0ZShcIiArICgod2lkdGggKyBtYXJnaW4ucmlnaHQgKyBtYXJnaW4ubGVmdCkgLyAyKSArIFwiICxcIiArXG4gICAgICAgICAgICAgICAgbWFyZ2luMy50b3AgKyBcIilcIilcbiAgICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgICAgLnRleHQoXCJEYXRlXCIpO1xuXG4gICAgICAgICAgICAvLyBEZWZpbmUgdGhlIGRpdiBmb3IgdGhlIHRvb2x0aXBcbiAgICAgICAgICAgIHZhciBkaXYgPSBkMy5zZWxlY3QoZWxlbWVudFswXSkuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ0b29sdGlwXCIpXG4gICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG5cblxuXG4gICAgICAgICAgICAvLyBhcHBlbmQgc2NhdHRlciBwbG90IHRvIGJydXNoIGNoYXJ0IGFyZWFcbiAgICAgICAgICAgIGNvbnRleHQuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYXhpcyBheGlzLS14XCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQyICsgXCIpXCIpXG4gICAgICAgICAgICAgIC5jYWxsKHhBeGlzMik7XG5cbiAgICAgICAgICAgIGNvbnRleHQuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYnJ1c2hcIilcbiAgICAgICAgICAgICAgLmNhbGwoYnJ1c2gpXG4gICAgICAgICAgICAgIC5jYWxsKGJydXNoLm1vdmUsIHgucmFuZ2UoKSk7XG5cbiAgICAgICAgICAgIHZhciBhcmVhMiA9IGQzLmFyZWEoKVxuICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXG4gICAgICAgICAgICAgIC54KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geDIoZC5EYXRlKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnkwKGhlaWdodDIpXG4gICAgICAgICAgICAgIC55MShmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHkyKGQuQ2xvc2UpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29udGV4dC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgIC5kYXR1bShkYXRhKVxuICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYXJlYVwiKVxuICAgICAgICAgICAgICAuYXR0cihcImRcIiwgYXJlYTIpO1xuXG5cbiAgICAgICAgICAgIGZyZWcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYXhpcyBheGlzLS14XCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQzICsgXCIpXCIpXG4gICAgICAgICAgICAgIC5jYWxsKHhBeGlzMylcbiAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCBcIi0uOGVtXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCItLjU1ZW1cIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJyb3RhdGUoLTkwKVwiKTtcblxuICAgICAgICAgICAgZnJlZy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJheGlzIGF4aXMtLXlcIilcbiAgICAgICAgICAgICAgLmNhbGwoeUF4aXMzKTtcblxuICAgICAgICAgICAgLy8gQWRkIGEgcmVjdCBmb3IgZWFjaCBkYXRlLlxuICAgICAgICAgICAgdmFyIHJlY3QgPSBmcmVnLnNlbGVjdEFsbChcInJlY3RcIilcbiAgICAgICAgICAgICAgLmRhdGEoZGF0YSlcbiAgICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYmFyXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwieFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgzKGQuRGF0ZSk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHkzKGQuSGlnaCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICB5MyhkLkhpZ2gpO1xuICAgICAgICAgICAgICAgIHkzKGQuTG93KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB5MyhkLkxvdykgLSB5MyhkLkhpZ2gpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHgzLmJhbmR3aWR0aCgpKTtcblxuXG5cbiAgICAgICAgICAgIC8vY3JlYXRlIGJydXNoIGZ1bmN0aW9uIHJlZHJhdyBzY2F0dGVycGxvdCB3aXRoIHNlbGVjdGlvblxuICAgICAgICAgICAgZnVuY3Rpb24gYnJ1c2hlZCgpIHtcblxuICAgICAgICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQgJiYgZDMuZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gXCJ6b29tXCIpIHJldHVybjsgLy8gaWdub3JlIGJydXNoLWJ5LXpvb21cblxuXG4gICAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBkMy5ldmVudC5zZWxlY3Rpb247XG4gICAgICAgICAgICAgIHguZG9tYWluKHNlbGVjdGlvbi5tYXAoeDIuaW52ZXJ0LCB4MikpO1xuICAgICAgICAgICAgICBmb2N1cy5zZWxlY3QoXCIuYXJlYVwiKS5hdHRyKFwiZFwiLCBhcmVhKTtcbiAgICAgICAgICAgICAgZm9jdXMuc2VsZWN0QWxsKFwiLmRvdFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoZC5EYXRlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY3lcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHkoZC5DbG9zZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGZvY3VzLnNlbGVjdChcIi5heGlzLS14XCIpLmNhbGwoeEF4aXMpO1xuXG4gICAgICAgICAgICAgIHgzLmRvbWFpbigpO1xuXG5cbiAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsZWN0aW9uLm1hcCh4Mi5pbnZlcnQsIHgyKTtcblxuICAgICAgICAgICAgICB4My5kb21haW4oZGF0YS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZVswXSA8PSBkLkRhdGUgJiYgZC5EYXRlIDw9IHJhbmdlWzFdKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuRGF0ZTtcbiAgICAgICAgICAgICAgfSkpO1xuXG5cbiAgICAgICAgICAgICAgZnJlZy5zZWxlY3RBbGwoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uKGQpIHtcblxuICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlWzBdIDw9IGQuRGF0ZSAmJiBkLkRhdGUgPD0gcmFuZ2VbMV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4MyhkLkRhdGUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChyYW5nZVswXSA8PSBkLkRhdGUgJiYgZC5EYXRlIDw9IHJhbmdlWzFdKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geTMoZC5IaWdoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkYXRlJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlWzBdIDw9IGQuRGF0ZSAmJiBkLkRhdGUgPD0gcmFuZ2VbMV0pXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZC5EYXRlO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZnVuY3Rpb24oZCkge1xuXG4gICAgICAgICAgICAgICAgICB5MyhkLkhpZ2gpO1xuICAgICAgICAgICAgICAgICAgeTMoZC5Mb3cpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAocmFuZ2VbMF0gPD0gZC5EYXRlICYmIGQuRGF0ZSA8PSByYW5nZVsxXSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiB5MyhkLkxvdykgLSB5MyhkLkhpZ2gpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB4My5iYW5kd2lkdGgoKSk7XG5cbiAgICAgICAgICAgICAgZnJlZy5zZWxlY3QoXCIuYXhpcy0teFwiKS5jYWxsKHhBeGlzMylcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcblxuICAgICAgICAgICAgICAgICAgaWYoISFkKXtcbiAgICAgICAgICAgICAgICAgICB2YXIgZm9ybWF0VGltZSA9IGQzLnRpbWVGb3JtYXQoXCIlbS0lZFwiKTtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0VGltZShkKTtcbiAgICAgICAgICAgICAgICAgIH19KVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCBcIi0uOGVtXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi0uNTVlbVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKC05MClcIik7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XSk7XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
